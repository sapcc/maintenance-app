#!/bin/bash

echo "===1) start web server"
# serve maintenance site
serve -l tcp://0.0.0.0:$PORT -s www &

# get current rules from ingress
INGRESS_ORIGIN_RULES=$(kubectl get ingress elektra -o jsonpath='{.spec.rules[*]}')

# replace service name and port
INGRESS_NEW_RULES=$(jq ".http.paths[].backend.service.name = \"$NAME\" | .http.paths[].backend.service.port = {\"number\":80}" <<< "$INGRESS_ORIGIN_RULES") 

echo "===2) create maintenance service"
# create a service 
kubectl create service clusterip $NAME --tcp=80:$PORT 

################ REDIRECT DASHBOARD URL TO MAINTENANCE URL ###################
echo "===3) Set the elektra app in maintenance mode... (patch ingress rules to point to maintenance service)"
# kubectl annotate ingress $INGRESS_NAME ingress.kubernetes.io/temporal-redirect="https://maintenance.global.cloud.sap"
kubectl patch ingress $INGRESS_NAME -p "{\"spec\": {\"rules\":[$INGRESS_NEW_RULES]}}"


echo "===4) exec pg container and execute backup"
kubectl exec -it deploy/$DEPLOYMENT_NAME -c backup -- /bin/bash -c 'BACKUP_PGSQL_FULL="1 mins" /usr/local/sbin/db-backup.sh'

# echo "===3) detirmine mount point"
# PGDATA=$(kubectl exec -it deploy/elektra-postgresql -c elektra-postgresql -- /bin/bash -c 'echo $PGDATA')
# VOLUME_MOUNTS=$(kubectl get deploy/elektra-postgresql -o jsonpath='{.spec.template.spec.containers[?(@.name=="elektra-postgresql")].volumeMounts}' )
# VOLUMES=$(kubectl get pods -o jsonpath='{.items[*].spec.containers[?(@.name=="elektra-postgresql")].volumeMounts}')


echo "===5) scale down pg pod"
kubectl scale deployment $DEPLOYMENT_NAME --replicas=0
kubectl wait --for delete pod --selector=app=$DEPLOYMENT_NAME --timeout=300s

echo "===6) delete pgdata"

kubectl run terminator --image busybox --rm -ti --restart=Never --overrides="
{ 
    \"spec\": {
        \"containers\": [
            {
                \"stdin\": true,
                \"tty\": true,
                \"args\": [ \"sh\", \"-c\", \"rm -rf /postgresql/data\" ],
                \"name\": \"db-terminator\",
                \"image\": \"busybox\",
                \"volumeMounts\": [
                    {
                      \"mountPath\": \"/postgresql\",
                      \"name\": \"data\"
                    }
                ]
            }
        ],
        \"volumes\": [
          {
            \"name\": \"data\",
            \"persistentVolumeClaim\": {
                \"claimName\": \"$PVC_NAME\"
            }
          }
        ]
    }
}
"

echo "===7) patch pg image version to $DB_VERSION"
kubectl patch deployment $DEPLOYMENT_NAME --patch "{\"spec\": {\"template\": {\"spec\": {\"containers\": [{\"name\": \"elektra-postgresql\",\"image\": \"keppel.eu-de-1.cloud.sap/ccloud/postgres:$DB_VERSION\"}]}}}}"

echo "===8) scale up pg pod"
kubectl scale deployment $DEPLOYMENT_NAME --replicas=1
kubectl wait deployment $DEPLOYMENT_NAME --for condition=Available=True --timeout=180s

echo "===9) restore backup"
kubectl exec -it deploy/$DEPLOYMENT_NAME -c backup -- /bin/bash -c 'yes 5  | backup-restore'

echo "===10) revert redirect to maintenance"
kubectl patch ingress $INGRESS_NAME -p "{\"spec\": {\"rules\":[$INGRESS_ORIGIN_RULES]}}"

##################### CLEANUP #########################
echo "===11) cleanup, delete $NAME service, delete $NAME deployment"
# delete service
kubectl delete service,deployment,role $NAME

echo "=== Done, now is the time to adjust the helm charts to use pg image version $DB_VERSION"

